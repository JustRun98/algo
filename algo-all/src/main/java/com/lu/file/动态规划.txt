思考 推荐先用选或不选来写，因为时间复杂度更低，为 O(n) , 而枚举选哪个通常时间复杂度为 O(n^2)
对于类似子序列（选和不选）：   q1911
-----------------------------------------------------------------------------------
q6899:求最大或者最小值时 在for中收集答案，永远不要用除Integer.MINVAL或Integer.MAXVAL外的任何值

记忆化搜索：
确定停止条件
对于取最大值的要确定res怎么初始化是初始化成-1还是初始化成Integer.MAXVALUE
-----------------------------------------------------------------------------------
有多少种装满背包的情况   01背包
q494 +1+1-1-1+1
q416 分割等和子集
-----------------------------------------------------------------------------------
求组合数量  完全背包
q518  硬币数量

求排列数量 完全背包
q377 组合总和

求排列数量 完全背包 求个数

求排列数量 完全背包 求能否

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。
每个target都会匹配一遍物品 通常初始化数组的时候target[0]=1

01背包的时候在遍历背包容量的时候必须倒序遍历，因为同一个物品不能被添加两次：
类似于滚动数组，后面的数据在滚动的时候会带上前面的数据，而前面的数据已经被更新过了（已经被加入了新的物品）

做题思路：
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。
本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。
那么我采用coins放在外循环，target在内循环的方式。
本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序

//todo:
对于01背包，背包要从后往前遍历

对于完全背包，背包要从前往后遍历
因为向后遍历的时候，取得之前的数据是已经被更新过的了，也就是本轮添加的物品已经出现在前面的数组中了
